-- File: malware-filter.lua
-- Author: Dylan Blanqu√©

local re -- Regex Module
if f.isModuleAvailable("rex_pcre") then
	re = require"rex_pcre"
elseif f.isModuleAvailable("rex_pcre2") then
	re = require"rex_pcre2"
else
	pdnslog(
		"pdns-recursor-scripts malware-filter.lua requires rex_pcre or rex_pcre2 to be installed",
		pdns.loglevels.Error
	)
	return false
end

local re_pat_adblock='^(\\|){2}(.*)\\^$' -- Matches Adblock Format
local re_pat_pcre="(.*)[$^|](.*)" -- Matches PCRE Format
local re_pat_wild="^\\*\\..*" -- Matches Wildcard Format
local re_pat_hosts="^(0.0.0.0|127.0.0.1|::|2001:1::1)\\s+.*" -- Matches HOSTS Format

-- Blocklist Objects (DS, CAS, NMG, Tables, etc.)
local mf_dnsbl = newDS()
local mf_rebl = {}
local mf_ipbl = newCAS()
local mf_cidrbl = newNMG()
local mf_whitelist_ds = newDS()
local mf_nxdomain_ds = newDS()

-- DNSBL Metrics
local dnsbl_hits = getMetric("dnsbl-hits")
local dnsbl_loaded_metric = getMetric("dnsbl-loaded")
local dnsbl_ignored_metric = getMetric("dnsbl-ignored")
local dnsbl_loaded_adblock = getMetric("dnsbl-loaded-adblock")
local dnsbl_loaded_pcre = getMetric("dnsbl-loaded-pcre")
local dnsbl_loaded_wildcard = getMetric("dnsbl-loaded-wildcard")
local dnsbl_loaded_hosts = getMetric("dnsbl-loaded-hosts")
local dnsbl_loaded_normal = getMetric("dnsbl-loaded-normal")

-- IPBL / CIDRBL Metrics
local ipbl_loaded_metric = getMetric("ipbl-loaded")
local cidrbl_loaded_metric = getMetric("cidrbl-loaded")
local ipbl_hits = getMetric("ipbl-hits")

-- Set NXDOMAIN Hosts
local nxdomain_hosts={
	"localhost",
	"localhost.localdomain",
	"local",
	"broadcasthost",
	"ip6-localhost",
	"ip6-loopback",
	"ip6-localnet",
	"ip6-mcastprefix",
	"ip6-allnodes",
	"ip6-allrouters",
	"ip6-allhosts",
}
for _, host in ipairs(nxdomain_hosts) do
	mf_nxdomain_ds:add(host)
end

local function get_list_files_in_dir(search_dir)
	local files = {}
	for dir in io.popen("ls -pa " .. search_dir .. " | grep -v / | grep -E \".*\\.(list|txt|hosts)$\""):lines() 
	do
		table.insert(files, search_dir .. "/" .. dir)
	end
	return files
end

-- Get relevant files
local dnsbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/dnsbl.d")
local ipbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/ipbl.d")

local function is_dq_internal(dq)
	pdnslog(
		"is_dq_internal(): checking if internal record for " .. tostring(dq.qname),
		pdns.loglevels.Debug
	)
	if mf_nxdomain_ds:check(dq.qname) then
		pdnslog(
			"is_dq_internal(): " .. tostring(dq.qname) .. " is internal",
			pdns.loglevels.Debug
		)
		return true
	end

	return false
end

local function is_dq_whitelisted(dq)
	pdnslog(
		"is_dq_whitelisted(): checking whitelist for " .. tostring(dq.qname),
		pdns.loglevels.Debug
	)
	if mf_whitelist_ds:check(dq.qname) then
		pdnslog(
			"is_dq_whitelisted(): " .. tostring(dq.qname) .. " is whitelisted",
			pdns.loglevels.Debug
		)
		return true
	end

	return false
end

local function is_qname_whitelisted(qname)
	if not qname or f.empty_str(qname) then
		return false
	end

	local dn = newDN(qname)
	if mf_whitelist_ds:check(dn) then
		return true
	end

	return false
end

-- Precompile regex patterns for better performance
local comment_or_empty = function(line) 
	return f.is_comment(line) or f.empty_str(line) 
end

-- loads contents of a file line by line with the given processing function
function load_list_file(fn_name, fn_process, filename)
	if not f.fileExists(filename) then
		pdnslog(
			fn_name .. "(): could not open file " .. filename,
			pdns.loglevels.Warning
		)
		return
	end

	-- Process each line
	local line_errors = 0
	local line_idx = 1
	for line in io.lines(filename) do
		local ok, result = pcall(function()
			return fn_process(line)
		end)
		if not ok then
			line_errors = line_errors + 1
			pdnslog(
				string.format(
					"%s(): could not parse line %d",
					fn_name,
					line_idx
				),
				pdns.loglevels.Error
			)
		end
		line_idx = line_idx + 1
	end

	pdnslog(
		string.format(
			"%s(): %s successfully loaded",
			fn_name,
			filename
		),
		pdns.loglevels.Notice
	)
	return line_errors
end

-- loads contents of a file line by line into the whitelist table
function load_whitelist_file(filename, whitelist_ds)
	-- Validate input parameters
	if type(filename) ~= "string" or not whitelist_ds then
		pdnslog("load_whitelist_file(): invalid parameters", pdns.loglevels.Error)
		return false
	end

	local function process_line(line)
		-- Ignore commented lines
		if comment_or_empty(line) then
			return
		end

		local dn = newDN(line)
		whitelist_ds:add(dn)
		pdnslog(
			line .. " is whitelisted",
			pdns.loglevels.Notice
		)
	end

	return load_list_file("load_whitelist_file", process_line, ipbl)
end

-- Loads contents of a file line by line into the dnsbl table
function load_dnsbl_file(filename, dnsbl_list, rebl_list)

	-- Validate input parameters
	if type(filename) ~= "string" or not dnsbl_list or not rebl_list then
		pdnslog("load_dnsbl_file(): invalid parameters", pdns.loglevels.Error)
		return false
	end

	local ignored_lines = 0
	local loaded_lines = 0
	local adblock_lines = 0
	local pcre_lines = 0
	local wildcard_lines = 0
	local hosts_lines = 0
	local normal_lines = 0
	local start_time = os.time()

	local function process_line(line)
		-- Trim whitespace from line
		line = line:match("^%s*(.-)%s*$")

		if comment_or_empty(line) then
			ignored_lines = ignored_lines + 1
			return
		end

		-- ADBLOCK FORMAT
		if re.match(line, re_pat_adblock) then
			local stripped = line:gsub("||", ""):gsub("%^", "")
			if is_qname_whitelisted(stripped) then
				return
			end
			dnsbl_list:add(stripped)
			loaded_lines = loaded_lines + 1
			adblock_lines = adblock_lines + 1

		-- PCRE FORMAT
		elseif re.match(line, re_pat_pcre) then
			table.insert(rebl_list, line)
			loaded_lines = loaded_lines + 1
			pcre_lines = pcre_lines + 1

		-- WILDCARD FORMAT
		elseif re.match(line, re_pat_wild) then
			local wilded = line:gsub('*%.', "")
			if is_qname_whitelisted(wilded) then
				return
			end
			dnsbl_list:add(wilded)
			loaded_lines = loaded_lines + 1
			wildcard_lines = wildcard_lines + 1

		-- HOSTS FORMAT
		elseif re.match(line, re_pat_hosts) then
			local host = f.extract_hosts_domain(line)
			host = f.trim_hosts_comment(host)
			if is_qname_whitelisted(host) then
				return
			end
			dnsbl_list:add(host)
			loaded_lines = loaded_lines + 1
			hosts_lines = hosts_lines + 1

		-- STANDARD FORMAT
		else
			dnsbl_list:add(line)
			loaded_lines = loaded_lines + 1
			normal_lines = normal_lines + 1
		end
	end

	-- Load file
	local errors = load_list_file("load_dnsbl_file", process_line, filename)
	local duration = os.time() - start_time

	-- Set general metrics
	dnsbl_loaded_metric:set(loaded_lines)
	-- Set detailed metrics
	dnsbl_loaded_adblock:set(adblock_lines)
	dnsbl_loaded_pcre:set(pcre_lines)
	dnsbl_loaded_wildcard:set(wildcard_lines)
	dnsbl_loaded_hosts:set(hosts_lines)
	dnsbl_loaded_normal:set(normal_lines)
	-- Set ignored metric
	dnsbl_ignored_metric:set(ignored_lines)

	return true
end

-- loads contents of a file line by line into the ipbl table
function load_ipbl_file(filename, ipbl_list, cidrbl_list)

	-- Validate input parameters
	if type(filename) ~= "string" or not ipbl_list or not cidrbl_list then
		pdnslog("load_ipbl_file(): invalid parameters", pdns.loglevels.Error)
		return false
	end

	local function process_line(line)
		-- Ignore commented lines
		if comment_or_empty(line) then
			return
		end

		-- Check if it's a CIDR
		if string.find(line, "/") then
			pdnslog(
				"load_ipbl_file(): loaded CIDR " .. line,
				pdns.loglevels.Debug
			)
			cidrbl_list:addMask(line)
			cidrbl_loaded_metric:inc()
		else -- Assume IP Address
			pdnslog(
				"load_ipbl_file(): loaded IP " .. line,
				pdns.loglevels.Debug
			)
			ipbl_list:add(line)
			ipbl_loaded_metric:inc()
		end
	end

	-- Load file
	load_list_file("load_ipbl_file", process_line, filename)
	return true
end

local function get_sinkhole(dq)
	if dq.qtype == pdns.A or dq.qtype == pdns.ANY then
		return {
			["0.0.0.0"]=pdns.A
		}
	elseif dq.qtype == pdns.AAAA or dq.qtype == pdns.ANY then
		return {
			["2001:1::1"]=pdns.AAAA
		}
	-- elseif dq.qtype == pdns.CNAME or dq.qtype == pdns.ANY then
	-- 	return {
	-- 		["0.0.0.0"]=pdns.A,
	-- 		["::"]=pdns.AAAA
	-- 	}
	end
	if dq.qtype == pdns.HTTPS then
		return {
			["1 . alpn=h3,h3-29,h2 ipv4hint=0.0.0.0 ipv6hint=2001:1::1"]=pdns.HTTPS
		}
	end
	return nil
end

-- this function is hooked before resolving starts
local function preresolve_mf(dq)
	if is_dq_internal(dq) then
		dq.appliedPolicy.policyKind = pdns.policykinds.NXDOMAIN
		return false
	end

	if is_dq_whitelisted(dq) then
		return false
	end

	-- If the last char is a dot, remove it (for non-canonical format)
	local qname_no_trailing_dot = f.qname_remove_trailing_dot(dq)
	local resolve_sinkhole = mf_dnsbl:check(dq.qname) -- NORMAL BL Check

	-- PCRE BL Check
	if not resolve_sinkhole then
		for k, p in pairs(mf_rebl) do
			if resolve_sinkhole then
				break
			end
			-- Log PCRE Pattern
			pdnslog(
				"PCRE Pattern: ".. qname_no_trailing_dot .." | " .. tostring(p),
				pdns.loglevels.Debug
			)
			resolve_sinkhole = re.match(qname_no_trailing_dot, p)
		end
	end

	pdnslog("Pre-Resolving " .. tostring(dq.qname), pdns.loglevels.Debug)
	pdnslog("PCRE Check: " .. tostring(re_check), pdns.loglevels.Debug)
	pdnslog("DNSBL Check: " .. tostring(ds_check), pdns.loglevels.Debug)
	-- check blocklist
	if resolve_sinkhole then
		local sinkhole = get_sinkhole(dq)
		if not sinkhole then
			dq.appliedPolicy.policyKind = pdns.policykinds.Drop
			return false
		end
		for dq_val, dq_qtype in pairs(sinkhole) do
			dq:addAnswer(dq_qtype, dq_val, g.options.default_ttl)
		end
		dnsbl_hits:inc()
		return true
	end

	-- default, do not rewrite this response
	pdnslog("Did not re-write " .. tostring(dq.qname), pdns.loglevels.Debug)
	return false
end

local function postresolve_mf(dq)
	if is_dq_whitelisted(dq) then
		return false
	end

	if dq.qtype ~= pdns.A and dq.qtype ~= pdns.AAAA then
		pdnslog(
			"Skipping postresolve_mf for ".. tostring(dq.qname),
			pdns.loglevels.Debug
		)
		return false
	end

	local dq_records = dq:getRecords()
	local blocked_records = {}
	local result_dq = {}
	local update_dq = false

	for dr_index, dr in ipairs(dq_records) do
		local dr_content = dr:getContent()
		local ip_check = false
		local cidr_check = false
		if not dr_content then
			pdnslog(
				"No DNSR Content for ".. tostring(dq.qname),
				pdns.loglevels.Debug
			)
			goto continue
		end
		-- Call function without raising exception to parent process
		local ok, dr_ca = pcall(newCA, dr_content)
		if not ok then
			goto continue
		end
		pdnslog("DNSR Content: " .. dr_ca:toString(), pdns.loglevels.Debug)

		if not ip_check and not cidr_check then
			cidr_check = mf_cidrbl:match(dr_ca)
			ip_check = mf_ipbl:check(dr_ca)
		end
		pdnslog("IP Check: " .. tostring(ip_check), pdns.loglevels.Debug)
		pdnslog("CIDR Check: " .. tostring(cidr_check), pdns.loglevels.Debug)

		if ip_check or cidr_check then
			update_dq = true
			table.insert(blocked_records, dr_index)
			for dq_val, dq_qtype in pairs(get_sinkhole(dq)) do
				dr:changeContent(dq_val)
			end
			pdnslog(
				string.format("Blocked Post-Resolving %s", tostring(dq.qname)),
				pdns.loglevels.Debug
			)
		else
			pdnslog(
				string.format("Allowed Post-Resolving %s", tostring(dq.qname)),
				pdns.loglevels.Debug
			)
		end
		::continue::
	end

	if update_dq then
		for i,v in ipairs(dq_records) do
			if not f.table_contains(blocked_records, i) then
				table.insert(result_dq, v)
			end
		end

		local use_result
		if f.table_len(result_dq) > 1 then
			use_result = result_dq
		else
			use_result = dq_records
		end

		dq:setRecords(use_result)
		pdnslog(
			string.format("Query Result %s", tostring(use_result)),
			pdns.loglevels.Debug
		)
		ipbl_hits:inc()
		return true
	end
	return false
end

-- Execute malware-filter main logic
-- Load Whitelist
load_whitelist_file(
	g.pdns_scripts_path.."/conf.d/whitelist.txt",
	mf_whitelist_ds
)

-- Load DNSBL
if g.options.use_dnsbl then
	for key, filename in pairs(dnsbl_file_table) do
		load_dnsbl_file(filename, mf_dnsbl, mf_rebl)
	end

	-- Add preresolve function to table
	pdnslog(
		"Loading preresolve_mf into pre-resolve functions.",
		pdns.loglevels.Debug
	)
	f.addResolveFunction("pre", "preresolve_mf", preresolve_mf)
else
	pdnslog("DNSBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
end

-- Load IPBL
if g.options.use_ipbl then
	for key, filename in pairs(ipbl_file_table) do
		load_ipbl_file(filename, mf_ipbl, mf_cidrbl)
	end

	-- Add postresolve function to table
	pdnslog(
		"Loading postresolve_mf into post-resolve functions.",
		pdns.loglevels.Debug
	)
	f.addResolveFunction("post", "postresolve_mf", postresolve_mf)
else
	pdnslog("IPBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
end
