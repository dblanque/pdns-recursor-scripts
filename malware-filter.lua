-- File: malware-filter.lua
-- Author: Dylan Blanqu√©

local re -- Regex Module
if f.isModuleAvailable("rex_pcre") then
	re = require"rex_pcre"
elseif f.isModuleAvailable("rex_pcre2") then
	re = require"rex_pcre2"
else
	pdnslog(
		"pdns-recursor-scripts malware-filter.lua requires rex_pcre or rex_pcre2 to be installed",
		pdns.loglevels.Error
	)
	return false
end

local re_pat_adblock='^(\\|){2}(.*)\\^$' -- Matches Adblock Format
local re_pat_pcre="(.*)[$^|](.*)" -- Matches PCRE Format
local re_pat_wild="^\\*\\..*" -- Matches Wildcard Format
local re_pat_hosts="^(0.0.0.0|127.0.0.1|::|2001:1::1)\\s+.*" -- Matches HOSTS Format

-- Blocklist Objects (DS, CAS, NMG, Tables, etc.)
local mf_dnsbl = newDS()
local mf_rebl = {}
local mf_ipbl = newCAS()
local mf_cidrbl = newNMG()

-- DNSBL Metrics
local dnsbl_hits = getMetric("dnsbl-hits")
local dnsbl_loaded_metric = getMetric("dnsbl-loaded")
local dnsbl_ignored_metric = getMetric("dnsbl-ignored")
local dnsbl_loaded_adblock = getMetric("dnsbl-loaded-adblock")
local dnsbl_loaded_pcre = getMetric("dnsbl-loaded-pcre")
local dnsbl_loaded_wildcard = getMetric("dnsbl-loaded-wildcard")
local dnsbl_loaded_hosts = getMetric("dnsbl-loaded-hosts")
local dnsbl_loaded_normal = getMetric("dnsbl-loaded-normal")

-- IPBL / CIDRBL Metrics
local ipbl_loaded_metric = getMetric("ipbl-loaded")
local cidrbl_loaded_metric = getMetric("cidrbl-loaded")
local ipbl_hits = getMetric("ipbl-hits")

nxdomain_hosts={
	"localhost",
	"localhost.localdomain",
	"local",
	"broadcasthost",
	"ip6-localhost",
	"ip6-loopback",
	"ip6-localnet",
	"ip6-mcastprefix",
	"ip6-allnodes",
	"ip6-allrouters",
	"ip6-allhosts",
}
mf_whitelist_ds = newDS()
mf_nxdomain_ds = newDS()
for _, host in ipairs(nxdomain_hosts) do
	mf_nxdomain_ds:add(host)
end

local function get_list_files_in_dir(search_dir)
	local files = {}
	for dir in io.popen("ls -pa " .. search_dir .. " | grep -v / | grep -E \".*\\.(list|txt|hosts)$\""):lines() 
	do
		table.insert(files, search_dir .. "/" .. dir)
	end
	return files
end

local function is_dq_internal(dq)
	pdnslog(
		"is_dq_internal(): checking if internal record for " .. tostring(dq.qname),
		pdns.loglevels.Debug
	)
	if mf_nxdomain_ds:check(dq.qname) then
		pdnslog(
			"is_dq_internal(): " .. tostring(dq.qname) .. " is internal",
			pdns.loglevels.Debug
		)
		return true
	end

	return false
end

local function is_dq_whitelisted(dq)
	pdnslog(
		"is_dq_whitelisted(): checking whitelist for " .. tostring(dq.qname),
		pdns.loglevels.Debug
	)
	if mf_whitelist_ds:check(dq.qname) then
		pdnslog(
			"is_dq_whitelisted(): " .. tostring(dq.qname) .. " is whitelisted",
			pdns.loglevels.Debug
		)
		return true
	end

	return false
end

local function is_qname_whitelisted(qname)
	if not qname or f.empty_str(qname) then
		return false
	end

	local dn = newDN(qname)
	if mf_whitelist_ds:check(dn) then
		return true
	end

	return false
end

-- loads contents of a file line by line into the given table
local function load_whitelist_file(filename)
	if f.fileExists(filename) then
		for line in io.lines(filename) do
			-- Ignore commented lines
			if f.is_comment(line) or f.empty_str(line) then
				goto continue
			end

			local dn = newDN(line)
			mf_whitelist_ds:add(dn)
			pdnslog(
				line .. " is whitelisted",
				pdns.loglevels.Notice
			)
			::continue::
		end
		pdnslog(
			"load_whitelist_file(): " .. filename .. " successfully loaded",
			pdns.loglevels.Notice
		)
	else
		pdnslog(
			"load_whitelist_file(): could not open file " .. filename,
			pdns.loglevels.Warning
		)
	end
end

-- loads contents of a file line by line into the given tablelocal dnsbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/dnsbl.d")
local dnsbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/dnsbl.d")
local ipbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/ipbl.d")
load_whitelist_file(g.pdns_scripts_path.."/conf.d/whitelist.txt")

-- Loads contents of a file line by line into the given table
function load_dnsbl_file(filename, dnsbl_list, rebl_list)

	-- Validate input parameters
	if type(filename) ~= "string" or not dnsbl_list or not rebl_list then
		pdnslog("load_dnsbl_file(): invalid parameters", pdns.loglevels.Error)
		return false
	end

	if not f.fileExists(filename) then
		pdnslog("load_dnsbl_file(): could not open file " .. filename, pdns.loglevels.Warning)
		return false
	end

	local ignored_lines = 0
	local loaded_lines = 0
	local adblock_lines = 0
	local pcre_lines = 0
	local wildcard_lines = 0
	local hosts_lines = 0
	local normal_lines = 0
	local start_time = os.time()
	
	-- Precompile regex patterns for better performance
	local comment_or_empty = function(line) 
		return f.is_comment(line) or f.empty_str(line) 
	end

	-- Process each line
	for line in io.lines(filename) do
		-- Trim whitespace from line
		line = line:match("^%s*(.-)%s*$")

		if comment_or_empty(line) then
			ignored_lines = ignored_lines + 1
			goto continue
		end

		-- ADBLOCK FORMAT
		if re.match(line, re_pat_adblock) then
			local stripped = line:gsub("||", ""):gsub("%^", "")
			if is_qname_whitelisted(stripped) then
				goto continue
			end
			dnsbl_list:add(stripped)
			loaded_lines = loaded_lines + 1
			adblock_lines = adblock_lines + 1

		-- PCRE FORMAT
		elseif re.match(line, re_pat_pcre) then
			table.insert(rebl_list, line)
			loaded_lines = loaded_lines + 1
			pcre_lines = pcre_lines + 1

		-- WILDCARD FORMAT
		elseif re.match(line, re_pat_wild) then
			local wilded = line:gsub('*%.', "")
			if is_qname_whitelisted(wilded) then
				goto continue
			end
			dnsbl_list:add(wilded)
			loaded_lines = loaded_lines + 1
			wildcard_lines = wildcard_lines + 1

		-- HOSTS FORMAT
		elseif re.match(line, re_pat_hosts) then
			local host = f.extract_hosts_domain(line)
			host = f.trim_hosts_comment(host)
			if is_qname_whitelisted(host) then
				goto continue
			end
			dnsbl_list:add(host)
			loaded_lines = loaded_lines + 1
			hosts_lines = hosts_lines + 1

		-- STANDARD FORMAT
		else
			dnsbl_list:add(line)
			loaded_lines = loaded_lines + 1
			normal_lines = normal_lines + 1
		end

		::continue::
	end

	local duration = os.time() - start_time
	-- Set general metric
	dnsbl_loaded_metric:set(loaded_lines)
	-- Set detailed metrics
	dnsbl_loaded_adblock:set(adblock_lines)
	dnsbl_loaded_pcre:set(pcre_lines)
	dnsbl_loaded_wildcard:set(wildcard_lines)
	dnsbl_loaded_hosts:set(hosts_lines)
	dnsbl_loaded_normal:set(normal_lines)
	-- Set ignored metric
	dnsbl_ignored_metric:set(ignored_lines)
	pdnslog(
		string.format(
			"load_dnsbl_file(): %s loaded successfully (%d entries, %d ignored, %0.2fs)", 
			filename, loaded_lines, ignored_lines, duration), 
		pdns.loglevels.Notice
	)

	return true
end

-- loads contents of a file line by line into the given table
function load_ipbl_file(filename, ipbl_list, cidrbl_list)
	if f.fileExists(filename) then
		for line in io.lines(filename) do
			pdnslog(
				"load_ipbl_file(): parsing line " .. line,
				pdns.loglevels.Debug
			)
			-- Ignore commented lines
			if f.is_comment(line) or f.empty_str(line) then
				goto continue
			end

			-- Check if it's a CIDR
			if string.find(line, "/") then
				pdnslog(
					"load_ipbl_file(): loaded CIDR " .. line,
					pdns.loglevels.Debug
				)
				cidrbl_list:addMask(line)
				cidrbl_loaded_metric:inc()
			else -- Assume IP Address
				pdnslog(
					"load_ipbl_file(): loaded IP " .. line,
					pdns.loglevels.Debug
				)
				ipbl_list:add(line)
				ipbl_loaded_metric:inc()
			end
			::continue::
		end
		pdnslog(
			"load_ipbl_file(): " .. filename .. " successfully loaded",
			pdns.loglevels.Notice
		)
	else
		pdnslog(
			"load_ipbl_file(): could not open file " .. filename,
			pdns.loglevels.Warning
		)
	end
end

local function get_sinkhole(dq)
	if dq.qtype == pdns.A or dq.qtype == pdns.ANY then
		return {
			["0.0.0.0"]=pdns.A
		}
	elseif dq.qtype == pdns.AAAA or dq.qtype == pdns.ANY then
		return {
			["2001:1::1"]=pdns.AAAA
		}
	-- elseif dq.qtype == pdns.CNAME or dq.qtype == pdns.ANY then
	-- 	return {
	-- 		["0.0.0.0"]=pdns.A,
	-- 		["::"]=pdns.AAAA
	-- 	}
	end
	if dq.qtype == pdns.HTTPS then
		return {
			["1 . alpn=h3,h3-29,h2 ipv4hint=0.0.0.0 ipv6hint=2001:1::1"]=pdns.HTTPS
		}
	end
	return nil
end

-- this function is hooked before resolving starts
local function preresolve_mf(dq)
	if is_dq_internal(dq) then
		dq.appliedPolicy.policyKind = pdns.policykinds.NXDOMAIN
		return false
	end

	if is_dq_whitelisted(dq) then
		return false
	end

	-- If the last char is a dot, remove it (for non-canonical format)
	local qname_no_trailing_dot = f.qname_remove_trailing_dot(dq)
	local resolve_sinkhole = mf_dnsbl:check(dq.qname) -- NORMAL BL Check

	-- PCRE BL Check
	if not resolve_sinkhole then
		for k, p in pairs(mf_rebl) do
			if resolve_sinkhole then
				break
			end
			-- Log PCRE Pattern
			pdnslog(
				"PCRE Pattern: ".. qname_no_trailing_dot .." | " .. tostring(p),
				pdns.loglevels.Debug
			)
			resolve_sinkhole = re.match(qname_no_trailing_dot, p)
		end
	end

	pdnslog("Pre-Resolving " .. tostring(dq.qname), pdns.loglevels.Debug)
	pdnslog("PCRE Check: " .. tostring(re_check), pdns.loglevels.Debug)
	pdnslog("DNSBL Check: " .. tostring(ds_check), pdns.loglevels.Debug)
	-- check blocklist
	if resolve_sinkhole then
		local sinkhole = get_sinkhole(dq)
		if not sinkhole then
			dq.appliedPolicy.policyKind = pdns.policykinds.Drop
			return false
		end
		for dq_val, dq_qtype in pairs(sinkhole) do
			dq:addAnswer(dq_qtype, dq_val, g.options.default_ttl)
		end
		dnsbl_hits:inc()
		return true
	end

	-- default, do not rewrite this response
	pdnslog("Did not re-write " .. tostring(dq.qname), pdns.loglevels.Debug)
	return false
end

local function postresolve_mf(dq)
	if is_dq_whitelisted(dq) then
		return false
	end

	if dq.qtype ~= pdns.A and dq.qtype ~= pdns.AAAA then
		pdnslog(
			"Skipping postresolve_mf for ".. tostring(dq.qname),
			pdns.loglevels.Debug
		)
		return false
	end

	local dq_records = dq:getRecords()
	local blocked_records = {}
	local result_dq = {}
	local ip_check = false
	local cidr_check = false

	for dr_index, dr in ipairs(dq_records) do
		local dr_content = dr:getContent()
		if not dr_content then
			pdnslog(
				"No DNSR Content for ".. tostring(dq.qname),
				pdns.loglevels.Debug
			)
			goto continue
		end
		-- Call function without raising exception to parent process
		local ok, dr_ca = pcall(newCA, dr_content)
		if not ok then
			goto continue
		end
		pdnslog("DNSR Content: " .. dr_ca:toString(), pdns.loglevels.Debug)

		if not ip_check and not cidr_check then
			cidr_check = mf_cidrbl:match(dr_ca)
			ip_check = mf_ipbl:check(dr_ca)
		end
		pdnslog("IP Check: " .. tostring(ip_check), pdns.loglevels.Debug)
		pdnslog("CIDR Check: " .. tostring(cidr_check), pdns.loglevels.Debug)

		if ip_check or cidr_check then
			table.insert(blocked_records, dr_index)
			for dq_val, dq_qtype in pairs(get_sinkhole(dq)) do
				dr:changeContent(dq_val)
			end
			pdnslog(
				string.format("Blocked Post-Resolving %s", tostring(dq.qname)),
				pdns.loglevels.Debug
			)
		else
			pdnslog(
				string.format("Allowed Post-Resolving %s", tostring(dq.qname)),
				pdns.loglevels.Debug
			)
		end
		::continue::
	end

	if ip_check or cidr_check then
		for i,v in ipairs(dq_records) do
			if not f.table_contains(blocked_records, i) then
				table.insert(result_dq, v)
			end
		end

		local use_result
		if f.table_len(result_dq) > 1 then
			use_result = result_dq
		else
			use_result = dq_records
		end

		dq:setRecords(use_result)
		pdnslog(
			string.format("Query Result %s", tostring(use_result)),
			pdns.loglevels.Debug
		)
		ipbl_hits:inc()
		return true
	end
	return false
end

if g.options.use_dnsbl then
	for key, filename in pairs(dnsbl_file_table) do
		load_dnsbl_file(filename, mf_dnsbl, mf_rebl)
	end

	-- pdnslog("Loading preresolve_mf into pre-resolve functions.", pdns.loglevels.Notice)
	-- Add preresolve function to table
	f.addResolveFunction("pre", "preresolve_mf", preresolve_mf)
else
	if not dnsbl_disabled_msg then
		pdnslog("DNSBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
	end
end
if g.options.use_ipbl then
	for key, filename in pairs(ipbl_file_table) do
		load_ipbl_file(filename, mf_ipbl, mf_cidrbl)
	end

	-- pdnslog("Loading postresolve_mf into post-resolve functions.", pdns.loglevels.Notice)
	-- Add postresolve function to table
	f.addResolveFunction("post", "postresolve_mf", postresolve_mf)
else
	pdnslog("IPBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
end