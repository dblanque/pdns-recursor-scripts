local function empty_str(s)
	return s == nil or s == ''
end

local function is_comment(v)
	if not v then return false end
	local p_list = {
		"^#(.*)$",
		"^%-%-(.*)$",
		"^//(.*)$"
	}
	for key, pattern in pairs(p_list) do
		if string.match(v, pattern) then return true end
	end
	return false
end
-- loads contents of a file line by line into the given table
function load_DNSBL_file(filename, dnsbl_list)
	if fileExists(filename) then
		for line in io.lines(filename) do
			dnsbl_list:add(line)
		end
		pdnslog("load_DNSBL_file(): " .. filename .. " successfully loaded", pdns.loglevels.Notice)
	else
		pdnslog("load_DNSBL_file(): could not open file " .. filename, pdns.loglevels.Warning)
	end
end
-- loads contents of a file line by line into the given table
function load_IPBL_file(filename, ipbl_list, cidrbl_list)
	if fileExists(filename) then
		for line in io.lines(filename) do
			if is_comment(line) or empty_str(line) then goto continue end -- Ignore commented lines
			if string.find(line, "/") then -- Check if it's a CIDR
				-- pdnslog("load_IPBL_file(): loading line for CIDR " .. line, pdns.loglevels.Notice)
				cidrbl_list:addMask(line)
			else -- Assume Normal Query Name
				-- pdnslog("load_IPBL_file(): loading line for IP " .. line, pdns.loglevels.Notice)
				ipbl_list:add(line)
			end
			::continue::
		end
		pdnslog("load_IPBL_file(): " .. filename .. " successfully loaded", pdns.loglevels.Notice)
	else
		pdnslog("load_IPBL_file(): could not open file " .. filename, pdns.loglevels.Warning)
	end
end

local function get_list_files_in_dir(search_dir)
	local files = {}
	for dir in io.popen("ls -pa "..search_dir.." | grep -v /|grep -E \"*(.list|.txt)\""):lines() 
	do
		table.insert(files, search_dir.."/"..dir)
	end
	return files
end

-- this function is hooked before resolving starts
function preresolve_mf(dq)
	local ds_check = dnsbl:check(dq.qname)
	local ip_check = ipbl:check(dq.remoteaddr)
	local cidr_check = cidrbl:match(dq.remoteaddr)
	pdnslog("IPBL Check Result: QTYPE " .. tostring(dq.qtype) .. " (".. tostring(dq.remoteaddr) ..") ".. tostring(ip_check), pdns.loglevels.Notice)
	pdnslog("DNSBL Check Result: QTYPE " .. tostring(dq.qtype) .. " (".. tostring(dq.remoteaddr) ..") ".. tostring(ds_check), pdns.loglevels.Notice)
	pdnslog("CIDR Check Result: QTYPE " .. tostring(dq.qtype) .. " (".. tostring(dq.remoteaddr) ..") ".. tostring(cidr_check), pdns.loglevels.Notice)
	-- check blocklist
	if ds_check or ip_check or cidr_check then
		if dq.qtype == pdns.A or dq.qtype == pdns.ANY then
			dq:addAnswer(pdns.A, "127.0.0.1")
		end

		if dq.qtype == pdns.AAAA or dq.qtype == pdns.ANY then
			dq:addAnswer(pdns.AAAA, "::1")
		end
		filterlist_metric:inc()
		return true
	end

	-- default, do not rewrite this response
	return false
end

local dnsbl_file_table = get_list_files_in_dir(pdns_scripts_path.."/dnsbl.d")
local ipbl_file_table = get_list_files_in_dir(pdns_scripts_path.."/ipbl.d")
dnsbl = newDS()
ipbl = newCAS()
cidrbl = newNMG()
for key, filename in pairs(dnsbl_file_table) do
	load_DNSBL_file(filename, dnsbl)
end
for key, filename in pairs(ipbl_file_table) do
	load_IPBL_file(filename, ipbl, cidrbl)
end

-- get metrics
filterlist_metric = getMetric("filterlist_hits")