local re
local re_pattern_adblock='^(\\|){2}(.*)\\^$' -- Matches Adblock Format
local re_chars="(.*)[$^|](.*)" -- Matches PCRE Format
local re_wild="^[*.]" -- Matches Wildcard Format
local re_hosts="^(0.0.0.0|127.0.0.1|::|2001:1::1)\\s+.*" -- Matches HOSTS Format

immutable_hosts={
	"localhost",
	"localhost.localdomain",
	"local",
	"broadcasthost",
	"ip6-localhost",
	"ip6-loopback",
	"ip6-localnet",
	"ip6-mcastprefix",
	"ip6-allnodes",
	"ip6-allrouters",
	"ip6-allhosts",
}
whitelist_ds = newDS()
for _, host in ipairs(immutable_hosts) do
	whitelist_ds:add(host)
end

if f.isModuleAvailable("rex_pcre") then
	re = require"rex_pcre"
elseif f.isModuleAvailable("rex_pcre2") then
	re = require"rex_pcre2"
else
	pdnslog("pdns-recursor-scripts malware-filter.lua requires rex_pcre or rex_pcre2 to be installed", pdns.loglevels.Error)
	return false
end

local function is_whitelisted(qname_no_trailing_dot)
	local dn = newDN(qname_no_trailing_dot)
	if whitelist_ds:check(dn) then
		return true
	end

	return false
end

-- loads contents of a file line by line into the given table
function load_whitelist_file(filename, whitelist)
	if f.fileExists(filename) then
		for line in io.lines(filename) do
			-- Ignore commented lines
			if f.is_comment(line) or f.empty_str(line) then
				goto continue
			end

			local dn = newDN(line)
			whitelist:add(dn)
			pdnslog(
				line .. "is whitelisted",
				pdns.loglevels.Notice
			)
			::continue::
		end
		pdnslog(
			"load_whitelist_file(): " .. filename .. " successfully loaded",
			pdns.loglevels.Notice
		)
	else
		pdnslog(
			"load_whitelist_file(): could not open file " .. filename,
			pdns.loglevels.Warning
		)
	end
end

-- Loads contents of a file line by line into the given table
function load_dnsbl_file(filename, dnsbl_list, rebl_list)
	-- Metrics
	local dnsbl_loaded_metric = getMetric("dnsbl_loaded")
	local dnsbl_ignored_metric = getMetric("dnsbl_ignored")
	local dnsbl_loaded_adblock = getMetric("dnsbl_loaded_adblock")
	local dnsbl_loaded_pcre = getMetric("dnsbl_loaded_pcre")
	local dnsbl_loaded_wildcard = getMetric("dnsbl_loaded_wildcard")
	local dnsbl_loaded_hosts = getMetric("dnsbl_loaded_hosts")
	local dnsbl_loaded_normal = getMetric("dnsbl_loaded_normal")

	-- Validate input parameters
	if type(filename) ~= "string" or not dnsbl_list or not rebl_list then
		pdnslog("load_dnsbl_file(): invalid parameters", pdns.loglevels.Error)
		return false
	end

	if not f.fileExists(filename) then
		pdnslog("load_dnsbl_file(): could not open file " .. filename, pdns.loglevels.Warning)
		return false
	end

	local ignored_lines = 0
	local loaded_lines = 0
	local start_time = os.time()
	
	-- Precompile regex patterns for better performance
	local comment_or_empty = function(line) 
		return f.is_comment(line) or f.empty_str(line) 
	end

	-- Process each line
	for line in io.lines(filename) do
		-- Trim whitespace from line
		line = line:match("^%s*(.-)%s*$")

		if comment_or_empty(line) then
			ignored_lines = ignored_lines + 1
			goto continue
		end

		-- ADBLOCK FORMAT
		if re.match(line, re_pattern_adblock) then
			local stripped = line:gsub("||", ""):gsub("%^", "")
			if is_whitelisted(stripped) then
				goto continue
			end
			dnsbl_list:add(stripped)
			loaded_lines = loaded_lines + 1
			dnsbl_loaded_adblock:inc()

		-- PCRE FORMAT
		elseif re.match(line, re_chars) then
			local domain = pcre_to_domain(regex)
			if is_whitelisted(domain) then
				goto continue
			end
			table.insert(rebl_list, line)
			loaded_lines = loaded_lines + 1
			dnsbl_loaded_pcre:inc()

		-- WILDCARD FORMAT
		elseif re.match(line, re_wild) then
			local wilded = line:gsub('*%.', "")
			if is_whitelisted(wilded) then
				goto continue
			end
			dnsbl_list:add(wilded)
			loaded_lines = loaded_lines + 1
			dnsbl_loaded_wildcard:inc()

		-- HOSTS FORMAT
		elseif re.match(line, re_hosts) then
			local host = f.extract_hosts_domain(line)
			host = f.trim_hosts_comment(host)
			if is_whitelisted(host) then
				goto continue
			end
			dnsbl_list:add(host)
			loaded_lines = loaded_lines + 1
			dnsbl_loaded_hosts:inc()

		-- STANDARD FORMAT
		else
			dnsbl_list:add(line)
			loaded_lines = loaded_lines + 1
			dnsbl_loaded_normal:inc()
		end

		::continue::
	end

	local duration = os.time() - start_time
	dnsbl_loaded_metric:set(loaded_lines)
	dnsbl_ignored_metric:set(ignored_lines)
	pdnslog(
		string.format(
			"load_dnsbl_file(): %s loaded successfully (%d entries, %d ignored, %0.2fs)", 
			filename, loaded_lines, ignored_lines, duration), 
		pdns.loglevels.Notice
	)

	return true
end

-- loads contents of a file line by line into the given table
function load_ipbl_file(filename, ipbl_list, cidrbl_list)
	local ipbl_loaded_metric = getMetric("ipbl_loaded")
	local cidrbl_loaded_metric = getMetric("cidrbl_loaded")
	if f.fileExists(filename) then
		for line in io.lines(filename) do
			-- pdnslog("load_ipbl_file(): parsing line " .. line, pdns.loglevels.Notice)
			if f.is_comment(line) or f.empty_str(line) then goto continue end -- Ignore commented lines
			if string.find(line, "/") then -- Check if it's a CIDR
				-- pdnslog("load_ipbl_file(): loaded CIDR " .. line, pdns.loglevels.Notice)
				cidrbl_list:addMask(line)
				cidrbl_loaded_metric:inc()
			else -- Assume IP Address
				-- pdnslog("load_ipbl_file(): loaded IP " .. line, pdns.loglevels.Notice)
				ipbl_list:add(line)
				ipbl_loaded_metric:inc()
			end
			::continue::
		end
		pdnslog("load_ipbl_file(): " .. filename .. " successfully loaded", pdns.loglevels.Notice)
	else
		pdnslog("load_ipbl_file(): could not open file " .. filename, pdns.loglevels.Warning)
	end
end

local function get_list_files_in_dir(search_dir)
	local files = {}
	for dir in io.popen("ls -pa " .. search_dir .. " | grep -v /|grep -E \"*(.list|.txt|.hosts)\""):lines() 
	do
		table.insert(files, search_dir .. "/" .. dir)
	end
	return files
end

local function get_sinkhole(dq)
	if dq.qtype == pdns.A or dq.qtype == pdns.ANY then
		return {
			["0.0.0.0"]=pdns.A
		}
	elseif dq.qtype == pdns.AAAA or dq.qtype == pdns.ANY then
		return {
			["2001:1::1"]=pdns.AAAA
		}
	-- elseif dq.qtype == pdns.CNAME or dq.qtype == pdns.ANY then
	-- 	return {
	-- 		["0.0.0.0"]=pdns.A,
	-- 		["::"]=pdns.AAAA
	-- 	}
	end
	if dq.qtype == pdns.HTTPS then
		return {
			["1 . alpn=h3,h3-29,h2 ipv4hint=0.0.0.0 ipv6hint=2001:1::1"]=pdns.HTTPS
		}
	end
	return nil
end

-- this function is hooked before resolving starts
local function preresolve_mf(dq)
	-- If the last char is a dot, remove it (for non-canonical format)
	local qname_no_trailing_dot = f.qname_remove_trailing_dot(dq)
	if is_whitelisted(qname_no_trailing_dot) then
		return false
	end
	local resolve_sinkhole = dnsbl:check(dq.qname) -- NORMAL BL Check

	-- PCRE BL Check
	if not resolve_sinkhole then
		for k, p in pairs(rebl) do
			if resolve_sinkhole then break end
			-- Log PCRE Pattern
			-- pdnslog("PCRE Pattern: ".. qname_no_trailing_dot .." | " .. tostring(p), pdns.loglevels.Notice)
			resolve_sinkhole = re.match(qname_no_trailing_dot, p)
		end
	end

	-- pdnslog("Pre-Resolving " .. tostring(dq.qname), pdns.loglevels.Notice)
	-- pdnslog("PCRE Check: " .. tostring(re_check), pdns.loglevels.Notice)
	-- pdnslog("DNSBL Check: " .. tostring(ds_check), pdns.loglevels.Notice)
	-- check blocklist
	if resolve_sinkhole then
		local sinkhole = get_sinkhole(dq)
		if not sinkhole then
			dq.appliedPolicy.policyKind = pdns.policykinds.Drop
			return false
		end
		for dq_val, dq_qtype in pairs(sinkhole) do
			dq:addAnswer(dq_qtype, dq_val, g.options.default_ttl)
		end
		local dnsbl_hits = getMetric("dnsbl_hits")
		dnsbl_hits:inc()
		return true
	end

	-- default, do not rewrite this response
	return false
end

local function postresolve_mf(dq)
	local dq_records = dq:getRecords()
	local ip_check = false
	local cidr_check = false
	if dq.qtype ~= pdns.A and dq.qtype ~= pdns.AAAA then return false end
	for key, dr in pairs(dq_records) do
		local dr_content = dr:getContent()
		if not dr_content or dr_content == nil then return false end
		-- Call function without raising exception to parent process
		local code, dr_ca = pcall(newCA, dr_content)
		if not code then return false end
		-- pdnslog("DNSR Content: " .. dr_ca:toString(), pdns.loglevels.Notice)
		if not ip_check and not cidr_check then
			cidr_check = cidrbl:match(dr_ca)
			ip_check = ipbl:check(dr_ca)
		end
		if ip_check or cidr_check then
			for dq_val, dq_qtype in pairs(get_sinkhole(dq)) do
				dr:changeContent(dq_val)
			end
			  
		end
		
		-- pdnslog("Post-Resolving " .. tostring(dq.qname), pdns.loglevels.Notice)
		-- pdnslog("IP Check: " .. tostring(ip_check), pdns.loglevels.Notice)
		-- pdnslog("CIDR Check: " .. tostring(cidr_check), pdns.loglevels.Notice)
		::continue::
	end
	if ip_check or cidr_check then
		dq:setRecords(dq_records)
		local ipbl_hits = getMetric("ipbl_hits")
		ipbl_hits:inc()
		return true
	end
	return false
end

-- loads contents of a file line by line into the given tablelocal dnsbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/dnsbl.d")
local dnsbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/dnsbl.d")
local ipbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/ipbl.d")
dnsbl = newDS()
rebl = {}
ipbl = newCAS()
cidrbl = newNMG()
load_whitelist_file(g.pdns_scripts_path.."conf.d/dnsbl_whitelist.txt")

if g.options.use_dnsbl then
	for key, filename in pairs(dnsbl_file_table) do
		load_dnsbl_file(filename, dnsbl, rebl)
	end

	-- pdnslog("Loading preresolve_mf into pre-resolve functions.", pdns.loglevels.Notice)
	-- Add preresolve function to table
	f.addResolveFunction("pre", "preresolve_mf", preresolve_mf)
else
	pdnslog("DNSBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
end
if g.options.use_ipbl then
	for key, filename in pairs(ipbl_file_table) do
		load_ipbl_file(filename, ipbl, cidrbl)
	end

	-- pdnslog("Loading postresolve_mf into post-resolve functions.", pdns.loglevels.Notice)
	-- Add postresolve function to table
	f.addResolveFunction("post", "postresolve_mf", postresolve_mf)
else
	pdnslog("IPBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
end