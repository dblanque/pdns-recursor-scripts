local function isModuleAvailable(name)
	if package.loaded[name] then
		return true
	else
		for _, searcher in ipairs(package.searchers or package.loaders) do
			local loader = searcher(name)
			if type(loader) == 'function' then
				package.preload[name] = loader
				return true
			end
		end
		return false
	end
end
local re
local re_pattern_adblock='^(\\|){2}(.*)\\^$'
local re_chars=".*[*$^|-].*"
if isModuleAvailable("rex_pcre") then
	re = require"rex_pcre"
else
	re = require"rex_pcre2"
end

local function empty_str(s)
	return s == nil or s == ''
end

local function table_contains (tab, val)
	for index, value in ipairs(tab) do
		-- pdnslog("IP Check: " .. tostring(value) .. " == " .. tostring(val) .." " .. tostring(value == val), pdns.loglevels.Notice)
		if value == val then
			return true
		end
	end
	return false
end

-- This function uses native LUA Regex, not PCRE2
local function is_comment(v)
	if not v then return false end
	local p_list = {
		"^#(.*)$",
		"^%-%-(.*)$",
		"^//(.*)$"
	}
	for key, pattern in pairs(p_list) do
		if string.match(v, pattern) then return true end
	end
	return false
end
-- loads contents of a file line by line into the given table
function load_DNSBL_file(filename, dnsbl_list, rebl_list)
	if fileExists(filename) then
		for line in io.lines(filename) do
			if re.match(line, re_pattern_adblock) then
				line = string.gsub(line, "||", "")
				line = string.gsub(line, "%^", "")
				dnsbl_list:add(line)
				pdnslog(line, pdns.loglevels.Notice)
			elseif re.match(line, re_chars) then
				table.insert(rebl_list, line)
			else
				dnsbl_list:add(line)
			end
		end
		pdnslog("load_DNSBL_file(): " .. filename .. " successfully loaded", pdns.loglevels.Notice)
	else
		pdnslog("load_DNSBL_file(): could not open file " .. filename, pdns.loglevels.Warning)
	end
end
-- loads contents of a file line by line into the given table
function load_IPBL_file(filename, ipbl_list, cidrbl_list)
	if fileExists(filename) then
		for line in io.lines(filename) do
			-- pdnslog("load_IPBL_file(): parsing line " .. line, pdns.loglevels.Notice)
			if is_comment(line) or empty_str(line) then goto continue end -- Ignore commented lines
			if string.find(line, "/") then -- Check if it's a CIDR
				-- pdnslog("load_IPBL_file(): loaded CIDR " .. line, pdns.loglevels.Notice)
				cidrbl_list:addMask(line)
			else -- Assume Normal Query Name
				-- pdnslog("load_IPBL_file(): loaded IP " .. line, pdns.loglevels.Notice)
				ipbl_list:add(line)
			end
			::continue::
		end
		pdnslog("load_IPBL_file(): " .. filename .. " successfully loaded", pdns.loglevels.Notice)
	else
		pdnslog("load_IPBL_file(): could not open file " .. filename, pdns.loglevels.Warning)
	end
end

local function get_list_files_in_dir(search_dir)
	local files = {}
	for dir in io.popen("ls -pa "..search_dir.." | grep -v /|grep -E \"*(.list|.txt)\""):lines() 
	do
		table.insert(files, search_dir.."/"..dir)
	end
	return files
end

local function get_sinkhole(dq)
	if dq.qtype == pdns.A or dq.qtype == pdns.ANY then
		return "127.0.0.1"
	end
	if dq.qtype == pdns.AAAA or dq.qtype == pdns.ANY then
		return "::1"
	end
end

-- this function is hooked before resolving starts
function preresolve_mf(dq)
	local ds_check = dnsbl:check(dq.qname)
	local re_check = false
	local qname_no_trailing_dot
	
	-- If the last char is a dot, remove it
	if string.sub(tostring(dq.qname), -1) == "." then
		qname_no_trailing_dot = string.sub(tostring(dq.qname), 1, -2)
	else
		qname_no_trailing_dot = tostring(dq.qname)
	end
	for k, p in pairs(rebl) do
		if re_check then break end
		pdnslog("PCRE Pattern: ".. qname_no_trailing_dot .." | " .. tostring(p), pdns.loglevels.Notice)
		re_check = re.match(qname_no_trailing_dot, p)
	end
	pdnslog("PCRE Check: " .. tostring(re_check), pdns.loglevels.Notice)
	pdnslog("DNSBL Check: " .. tostring(ds_check), pdns.loglevels.Notice)
	-- check blocklist
	if ds_check or re_check then
		dq:addAnswer(dq.qtype, get_sinkhole(dq))
		filterlist_metric:inc()
		return true
	end
	
	-- default, do not rewrite this response
	return false
end

function postresolve_mf(dq)
	local dq_records = dq:getRecords()
	local ip_check = false
	local cidr_check = false
	if dq.qtype ~= pdns.A and dq.qtype ~= pdns.AAAA then return false end
	for key, dr in pairs(dq_records) do
		local dr_content = dr:getContent()
		if not dr_content or dr_content == nil then return false end
		local code, dr_ca = pcall(newCA, dr_content)
		if not code then return false end
		-- pdnslog("DNSR Content: " .. dr_ca:toString(), pdns.loglevels.Notice)
		if not ip_check and not cidr_check then
			cidr_check = cidrbl:match(dr_ca)
			ip_check = ipbl:check(dr_ca)
		end
		if ip_check or cidr_check then
			dr:changeContent(get_sinkhole(dq))
		end
		
		-- pdnslog("IP Check: " .. tostring(ip_check), pdns.loglevels.Notice)
		-- pdnslog("CIDR Check: " .. tostring(cidr_check), pdns.loglevels.Notice)
		::continue::
	end
	if ip_check or cidr_check then
		dq:setRecords(dq_records)
		return true
	end
	return false
end

local dnsbl_file_table = get_list_files_in_dir(pdns_scripts_path.."/dnsbl.d")
local ipbl_file_table = get_list_files_in_dir(pdns_scripts_path.."/ipbl.d")
dnsbl = newDS()
rebl = {}
ipbl = newCAS()
cidrbl = newNMG()
for key, filename in pairs(dnsbl_file_table) do
	load_DNSBL_file(filename, dnsbl, rebl)
end
for key, filename in pairs(ipbl_file_table) do
	load_IPBL_file(filename, ipbl, cidrbl)
end

-- get metrics
filterlist_metric = getMetric("filterlist_hits")