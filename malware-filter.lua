local re
local re_pattern_adblock='^(\\|){2}(.*)\\^$' -- Matches Adblock Format
local re_chars="(.*)[$^|](.*)" -- Matches PCRE Format
local re_wild="^[*.]" -- Matches Wildcard Format
if isModuleAvailable("rex_pcre") then
	re = require"rex_pcre"
elseif isModuleAvailable("rex_pcre2") then
	re = require"rex_pcre2"
else
	error("pdns-recursor-scripts malware-filter.lua requires rex_pcre or rex_pcre2 to be installed")
end

-- loads contents of a file line by line into the given table
function load_dnsbl_file(filename, dnsbl_list, rebl_list, wildbl_list)
	if fileExists(filename) then
		for line in io.lines(filename) do
			if is_comment(line) or empty_str(line) then goto continue end -- Ignore commented lines
			if re.match(line, re_pattern_adblock) then -- ADBLOCK FORMAT
				local stripped = string.gsub(line, "||", "")
				stripped = string.gsub(stripped, "%^", "") -- Escape Special character ^ with %
				dnsbl_list:add(stripped)
			elseif re.match(line, re_chars) then -- PCRE FORMAT
				table.insert(rebl_list, line)
			elseif re.match(line, re_wild) then -- WILDCARD FORMAT
				local wilded = string.gsub(line, '*%.', "") -- Escape Special character . with %
				wilded = ".*\\.*"..string.gsub(wilded, '%.', "\\.") -- Escape Special Characters
				table.insert(wildbl_list, wilded)
			else -- STANDARD HOSTS FORMAT
				dnsbl_list:add(line)
			end
			::continue::
		end
		pdnslog("load_dnsbl_file(): " .. filename .. " successfully loaded", pdns.loglevels.Notice)
	else
		pdnslog("load_dnsbl_file(): could not open file " .. filename, pdns.loglevels.Warning)
	end
end

-- loads contents of a file line by line into the given table
function load_ipbl_file(filename, ipbl_list, cidrbl_list)
	if fileExists(filename) then
		for line in io.lines(filename) do
			-- pdnslog("load_ipbl_file(): parsing line " .. line, pdns.loglevels.Notice)
			if is_comment(line) or empty_str(line) then goto continue end -- Ignore commented lines
			if string.find(line, "/") then -- Check if it's a CIDR
				-- pdnslog("load_ipbl_file(): loaded CIDR " .. line, pdns.loglevels.Notice)
				cidrbl_list:addMask(line)
			else -- Assume IP Address
				-- pdnslog("load_ipbl_file(): loaded IP " .. line, pdns.loglevels.Notice)
				ipbl_list:add(line)
			end
			::continue::
		end
		pdnslog("load_ipbl_file(): " .. filename .. " successfully loaded", pdns.loglevels.Notice)
	else
		pdnslog("load_ipbl_file(): could not open file " .. filename, pdns.loglevels.Warning)
	end
end

local function get_list_files_in_dir(search_dir)
	local files = {}
	for dir in io.popen("ls -pa "..search_dir.." | grep -v /|grep -E \"*(.list|.txt)\""):lines() 
	do
		table.insert(files, search_dir.."/"..dir)
	end
	return files
end

local function get_sinkhole(dq)
	if dq.qtype == pdns.A or dq.qtype == pdns.ANY then
		return "127.0.0.1"
	end
	if dq.qtype == pdns.AAAA or dq.qtype == pdns.ANY then
		return "::1"
	end
end

-- this function is hooked before resolving starts
function preresolve_mf(dq)
	local ds_check = dnsbl:check(dq.qname)
	local re_check = false
	local wild_check = false
	local qname_no_trailing_dot
	
	-- If the last char is a dot, remove it (we don't want canonical format)
	if string.sub(tostring(dq.qname), -1) == "." then
		qname_no_trailing_dot = string.sub(tostring(dq.qname), 1, -2)
	else
		qname_no_trailing_dot = tostring(dq.qname)
	end
	for k, p in pairs(rebl) do
		if ds_check or re_check then break end
		-- Log PCRE Pattern
		-- pdnslog("PCRE Pattern: ".. qname_no_trailing_dot .." | " .. tostring(p), pdns.loglevels.Notice)
		re_check = re.match(qname_no_trailing_dot, p)
	end

	for k, p in pairs(wildbl) do
		if ds_check or re_check or wild_check then break end
		-- Log Wildcard Pattern
		-- pdnslog("WILD Pattern: ".. qname_no_trailing_dot .." | " .. tostring(p), pdns.loglevels.Notice)
		wild_check = re.match(qname_no_trailing_dot, p)
	end
	-- pdnslog("Pre-Resolving " .. tostring(dq.qname), pdns.loglevels.Notice)
	-- pdnslog("PCRE Check: " .. tostring(re_check), pdns.loglevels.Notice)
	-- pdnslog("DNSBL Check: " .. tostring(ds_check), pdns.loglevels.Notice)
	-- check blocklist
	if ds_check or re_check or wild_check then
		dq:addAnswer(dq.qtype, get_sinkhole(dq))
		filterlist_metric:inc()
		return true
	end
	
	-- default, do not rewrite this response
	return false
end

function postresolve_mf(dq)
	local dq_records = dq:getRecords()
	local ip_check = false
	local cidr_check = false
	if dq.qtype ~= pdns.A and dq.qtype ~= pdns.AAAA then return false end
	for key, dr in pairs(dq_records) do
		local dr_content = dr:getContent()
		if not dr_content or dr_content == nil then return false end
		local code, dr_ca = pcall(newCA, dr_content)
		if not code then return false end
		-- pdnslog("DNSR Content: " .. dr_ca:toString(), pdns.loglevels.Notice)
		if not ip_check and not cidr_check then
			cidr_check = cidrbl:match(dr_ca)
			ip_check = ipbl:check(dr_ca)
		end
		if ip_check or cidr_check then
			dr:changeContent(get_sinkhole(dq))
		end
		
		-- pdnslog("Post-Resolving " .. tostring(dq.qname), pdns.loglevels.Notice)
		-- pdnslog("IP Check: " .. tostring(ip_check), pdns.loglevels.Notice)
		-- pdnslog("CIDR Check: " .. tostring(cidr_check), pdns.loglevels.Notice)
		::continue::
	end
	if ip_check or cidr_check then
		dq:setRecords(dq_records)
		return true
	end
	return false
end

local dnsbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/dnsbl.d")
local ipbl_file_table = get_list_files_in_dir(g.pdns_scripts_path.."/ipbl.d")
dnsbl = newDS()
rebl = {}
wildbl = {}
ipbl = newCAS()
cidrbl = newNMG()

-- get metrics
filterlist_metric = getMetric("filterlist_hits")

if g.options.use_dnsbl then
	for key, filename in pairs(dnsbl_file_table) do
		load_dnsbl_file(filename, dnsbl, rebl, wildbl)
	end

	pdnslog("Loading preresolve_mf into pre-resolve functions.", pdns.loglevels.Notice)
	-- Add preresolve function to table
	addResolveFunction("pre", "preresolve_mf", preresolve_mf)
else
	pdnslog("DNSBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
end
if g.options.use_ipbl then
	for key, filename in pairs(ipbl_file_table) do
		load_ipbl_file(filename, ipbl, cidrbl)
	end

	pdnslog("Loading postresolve_mf into post-resolve functions.", pdns.loglevels.Notice)
	-- Add postresolve function to table
	addResolveFunction("post", "postresolve_mf", postresolve_mf)
else
	pdnslog("IPBL Function not enabled. Set overrides in file overrides.lua", pdns.loglevels.Notice)
end